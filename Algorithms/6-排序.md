# 排序

## 排序算法分析

* 排序算法的执行效率

  1. 最好情况、最坏情况、平均情况时间复杂度

  2. 时间复杂度的系数、常数 、低阶

  3. 比较次数和交换（或移动）次数

* 排序算法的内存消耗

    原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。我们今天讲的三种排序算法，都是原地排序算法。

* 排序算法的稳定性

    针对排序算法，还有一个重要的度量指标，稳定性。如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

* 排序对比

![排序对比](./resource/sort.png)

### 冒泡排序（Bubble Sort）

![冒泡排序](./resource/bubbleSort.gif)

[代码示例](./resource/sort_test.go)

### 选择排序（Selection Sort）

> 思路：选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![选择排序](./resource/selectionSort.gif)

[代码示例](./resource/sort_test.go)

### 插入排序（Insertion Sort）

> 思想：将数组分为两个区间，`已排序区间`,`未排序区间`，初始已排序区间只有第一个元素,取未排序区间的元素在已排序区间找到合适的位置插入，并保证已排序区间一直有序，重复此过程，知道未排序区间元素为空

![插入排序](./resource/insertionSort.gif)

1. 插入排序算法的运行并不需要额外的存储空间，空间复杂度是O(1)，是一个原地排序算法
2. 对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
3. 最好时间复杂为O(n) 最坏时间复杂度O(n^2)

[代码示例](./resource/sort_test.go)

### 归并排序（Merge Sort）

![归并排序](./resource/mergeSort.gif)

思想：归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。
>分治是一种解决问题的处理思想，递归是一种编程技巧

```.
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```

```伪代码
// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
```

* 归并排序的性能分析

  1. 归并排序是一个稳定的排序算法
  2. 时间复杂度O(nlogn)
  3. 空间复杂度是 O(n)

### 快速排序（Quicksort）

> 思想: 如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。

<img src="./resource/归并-快速排序对比.jpg" width = "600" height = "400"/>

### 桶排序（Bucket sort）

1. 算法原理：
    * 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。
    * 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

2. 使用条件
    * 要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。
    * 数据在各个桶之间分布是均匀的。
3. 适用场景
    * 桶排序比较适合用在外部排序中。
    * 外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。
4. 应用案例
    * 需求描述：有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序 但内存有限，仅几百MB
    * 解决思路：扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。将100个小文件依次放入内存并用快排排序。所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。  
    * 注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。

### 计数排序（Counting sort）

1. 算法原理
    * 计数其实就是桶排序的一种特殊情况。
    * 当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶
    * 每个桶内的数据值都是相同的，就省掉了桶内排序的时间。
2. 案例分析：假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。
C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。  
对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。  
数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？  
从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。
以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。
3. 使用条件
    * 只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；
    * 计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；
    * 比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。

### 基数排序（Radix sort）

1. 算法原理（以排序10万个手机号为例来说明）
    * 比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。
    * 借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。
    * 经过11次排序后，手机号码就变为有序的了。
    * 每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。
2. 使用条件
    * 要求数据可以分割独立的“位”来比较；
    * 位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；
    * 每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。

## References

  https://www.runoob.com/w3cnote/ten-sorting-algorithm.html
