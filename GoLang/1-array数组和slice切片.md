#

* [基本概念](#数组(array)和切片(slice))
* [笔试题](./code/array/array_slice_test.go)

## 数组(array)和切片(slice)

* 共同点:都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。

* 不同点:数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。

> 数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，数组的长度是其类型的一部分。比如，[1]string和[2]string就是两个不同的数组类型。而切片的类型字面量中只有元素的类型，而没有长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。

![数组和切片](./resource/数组和切片.png)

我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。

> 也正因为如此，Go 语言的切片类型属于`引用类型`，同属引用类型的还有`字典类型`、`通道类型`、`函数类型`等；而 Go 语言的数组类型则属于`值类型`，同属值类型的有`基础数据类型`以及`结构体类型`。注意，Go 语言里不存在像 Java 等编程语言中令人困惑的“传值或传引用”问题。在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看**被传递的值的类型**就好了。如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片。

[示例代码](./code/array/array_slice_test.go)

```go
package main

import "fmt"

func main() {
  s1 := make([]int, 5)
  fmt.Printf("The length of s1: %d\n", len(s1))
  fmt.Printf("The capacity of s1: %d\n", cap(s1))
  fmt.Printf("The value of s1: %d\n", s1)
  s2 := make([]int, 5, 8)
  fmt.Printf("The length of s2: %d\n", len(s2))
  fmt.Printf("The capacity of s2: %d\n", cap(s2))
  fmt.Printf("The value of s2: %d\n", s2)

  s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
  s4 := s3[3:6]
  fmt.Printf("The length of s4: %d\n", len(s4))
  fmt.Printf("The capacity of s4: %d\n", cap(s4))
  fmt.Printf("The value of s4: %d\n", s4)
}
```

每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。
s2的容量8 表示其底层数组的长度为8,引用的底层数组的5
对于s4为s3[3,6) 长度为3, s4可以从s3[3]开始向右扩展直到s3结尾,所以s4的容量为5
![切片数组关系](./resource/数组切片关系.png)

### 切片容量的增长规律

一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并`拷贝`到新切片中。在一般的情况下，可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。但是，当原切片的长度（以下简称原长度）大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。

另外，如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。更多细节可参见runtime包中 slice.go 文件里的growslice及相关函数的具体实现。

[示例代码](./code/array/array_slice_test.go)

无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。所以，严格来讲，“扩容”这个词用在这里虽然形象但并不合适。
