#

## 通道

> Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）  ——Rob Pike(go创造者之一)

通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。

[示例代码](./code/)

```go
package main

import "fmt"

func main() {
  ch1 := make(chan int, 3)
  ch1 <- 2
  ch1 <- 1
  ch1 <- 3
  elem1 := <-ch1
  fmt.Printf("The first element received from channel ch1: %v\n",
    elem1)
}
```

在声明并初始化一个通道的时候，需要用到 Go 语言的内建函数make。
就像用make初始化切片那样，传给这个函数的第一个参数应该是代表了通道的具体类型的类型字面量。在声明一个通道类型变量的时候，首先要确定该通道类型的元素类型，这决定了可以通过这个通道传递什么类型的数据。

比如，类型字面量chan int，其中的chan是表示通道类型的关键字，而int则说明了该通道类型的元素类型。

又比如，chan string代表了一个元素类型为string的通道类型。

在初始化通道的时候，make函数除了必须接收这样的类型字面量作为参数，还可以接收一个int类型的参数。后者是可选的，用于表示该通道的容量。所谓通道的容量，就是指通道最多可以缓存多少个元素值。由此，虽然这个参数是int类型的，但是它是不能小于0的。当容量为0时，我们可以称通道为`非缓冲通道`，也就是不带缓冲的通道。而当容量大于0时，我们可以称为`缓冲通道`，也就是带有缓冲的通道。非缓冲通道和缓冲通道有着不同的数据传递方式。

> 一个通道相当于一个`先进先出（FIFO）的队列`。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到`操作符<-`。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。

### 通道的特性

1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。

    运行时系统只会执行对同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。

    * 这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。

1. 发送操作和接收操作中对元素值的处理都是不可分割的。

    不可分割”的意思是，它们处理元素值时都是一气呵成的，绝不会被打断。

    例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。

    又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。

1. 发送操作在完全完成之前会被阻塞。接收操作也是如此。

    一般情况下，发送操作包括了`复制元素值`和`放置副本到通道内部`这两个步骤。

    在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。

    也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。

    另外，接收操作通常包含了`复制通道内的元素值`,`放置副本到接收方`,`删掉原值`三个步骤。在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。

### 通道阻塞

* 缓冲通道下

    如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。

    这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。由于发送操作在这种情况下被阻塞后，它们所在的 goroutine 会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。

    相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。因此而等待的、所有接收操作所在的 goroutine，都会按照先后顺序被放入通道内部的接收等待队列。

* 非缓冲通道下，

    无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。

> 由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。在大多数情况下，缓冲通道会作为收发双方的中间件。元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。以上说的都是在正确使用通道的前提下会发生的事情。

特别说明一下，由于错误使用通道而造成的阻塞。对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。

注意，由于通道类型是引用类型，所以它的零值就是nil。换句话说，当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。一定不要忘记初始化通道！

### 通道panic

* 对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。

* 另外，如果试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。

### 单向通道

> 用途: 概括地说，单向通道最主要的用途就是约束其他代码的行为。
