#

## 2019-12-23

### 弹力设计

`容错设计`又叫`弹力设计`，其中着眼于分布式系统的各种“容忍”能力，包括容错能力（服务隔离、异步调用、请求幂等性）、可伸缩性（有 / 无状态的服务）、一致性（补偿事务、重试）、应对大流量的能力（熔断、降级）。可以看到，在确保系统正确性的前提下，系统的可用性是弹力设计保障的重点。

对于分布式系统的容错设计，在英文中又叫 Resiliency（弹力）。意思是，系统在不健康、不顺，甚至出错的情况下有能力 hold 得住，挺得住，还有能在这种逆境下力挽狂澜的能力。

### 系统可用性

![可用性](./resource/容错能力公式.png)

## 2019-12-24

### 隔离设计

隔离设计对应的单词是 `Bulkheads`,中文翻译为隔板。但其实，这个术语是用在造船上的，也就是船舱里防漏水的隔板。一般的船无论大小都会有这个东西，大一点的船都会把船舱隔成若干个空间。这样，如果船舱漏水，只会进到一个小空间里，不会让整个船舱都进水而导致整艘船都沉了。 在分布式软件架构中，我们使用类似的技术来让我们的故障得到隔离。这就需要我们对系统进行分离。一般来说，对于系统的分离有两种方式，一种是以服务的种类来做分离，一种是以用户来做分离。下面具体说明一下这两种方式。

### 按服务的种类来做分离

我们将系统分成多个板块。这每个板块分别使用不同的域名、服务器和数据库，做到从接入层到应用层再到数据层三层完全隔离。这样一来，在物理上来说，一个板块的故障就不会影响到另一板块。

### 按用户的请求来做分离

完全独立的设计。每个租户有自己完全独立的服务和数据。
独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。
共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。

## 2019-12-25

### 异步通讯设计

### 同步调用弊端

通讯一般来说分同步和异步两种。同步通讯就像打电话，需要实时响应，而异步通讯就像发邮件，不需要马上回复。
同步调用虽然让系统间只耦合于接口，而且实时性也会比异步调用要高，但是我们也需要知道同步调用会带来如下几个问题。
1. 同步调用需要被调用方的吞吐不低于调用方的吞吐。否则会导致被调用方因为性能不足而拖死调用方。换句话说，整个同步调用链的性能会由最慢的那个服务所决定。
2. 同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。同步调用只能是一对一的，很难做到一对多。
3. 同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。

异步通讯相对于同步通讯来说，除了可以增加系统的吞吐量之外，最大的一个好处是其可以让服务间的`解耦`更为彻底，系统的调用方和被调用方可以按照自己的速率而不是步调一致，从而可以更好地保护系统，让系统更有弹力。

### 异步通讯的三种方式

1. 请求响应式
    两种方式：
    * 发送方不断轮询
    * 发送方注册一个回调方法，也就是接收方处理完后回调请求方,(比如微信支付)
2. 通过订阅的方式
    这种情况下，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。
3. 通过 Broker 的方式
    所谓 Broker，就是一个中间人，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。
    ![Broker](./resource/Broker方式.png)
    
    这是完全的解耦。所有的服务都不需要相互依赖，而是依赖于一个中间件 Broker。这个 Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。

## 2019-12-26

### 幂等性设计

> 分布式服务的设计应该满足幂等性，幂等性的含义是，一个调用被发送多次所产生的副作用和被发送一次所产生的副作用是一样的。由于每次服务的调用有三种状态，成功失败或是超时，幂等性是要解决超时的问题，当某处调用超时，如何保证重复调用而逻辑不会出错

### 解决问题

创建全局ID

## 2019-12-27 

### 服务的状态

>“状态”，就是为了保留程序的一些数据或是上下文。比如之前幂等性设计中所说的需要保留每一次请求的状态，或是像用户登录时的 Session，我们需要这个 Session 来判断这个请求的合法性，还有一个业务流程中需要让多个服务组合起来形成一个业务逻辑的运行上下文 Context。这些都是所谓的状态。

### 无状态的服务 Stateless

无状态的服务都被当作分布式服务设计的最佳实践和铁律。因为无状态的服务对于扩展性和运维实在是太方便了。

没有状态的服务，可以随意地增加和减少结点，同样可以随意地搬迁。
无状态的服务可以大幅度降低代码的复杂度以及 Bug 数，因为没有状态，所以也没有明显的“副作用”。

为了做出无状态的服务，我们通常需要把状态保存到其他的地方。比如 Redis MySQL 或是像 ZooKeeper/Etcd 这样的高可用的强一致性的存储中，或是分布式文件系统中

### 有状态的服务 Stateful

而有状态的服务有这些好处。数据本地化（Data Locality）。
一方面状态和数据是本机保存，这方面不但有更低的延时，而且对于数据密集型的应用来说，这会更快。
更高的可用性和更强的一致性。也就是 CAP 原理中的 A 和 C。

## 2020-01-01

### 补偿事务

### ACID

* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation，又称独立性）
* 持久性（Durability

### BASE

事务的 ACID 属性保证了数据库的一致性，比如银行系统中，转账就是一个事务，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和构成一个完整的逻辑过程，是不可拆分的原子操作，从而保证了整个系统中的总金额没有变化。

然而，这对于我们的分布式系统来说，尤其是微服务来说，这样的方式是很难满足高性能要求的。

CAP 理论——在分布式的服务架构中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition Tolerance），在现实中不能都满足，最多只能满足其中两个。所以，为了提高性能，出现了 ACID 的一个变种 BASE。

Basic Availability：基本可用。这意味着，系统可以出现暂时不可用的状态，而后面会快速恢复。
Soft-state：软状态。它是我们前面的“有状态”和“无状态”的服务的一种中间状态。也就是说，为了提高性能，我们可以让服务暂时保存一些状态或数据，这些状态和数据不是强一致性的。
Eventual Consistency：最终一致性，系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一致的。可以看到，BASE 系统是允许或是容忍系统出现暂时性问题的，这样一来，我们的系统就能更有弹力。因为我们知道，在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。

### 业务补偿的设计重点

1. 努力地把一个业务流程执行完成。
2. 如果执行不下去，需要启动补偿机制，回滚业务流程。

## 2020-01-03

### 重试设计

网络上有很多的各式各样的组件，如 DNS 服务、网卡、交换机、路由器、负载均衡等设备，这些设备都不一定是稳定的。在数据传输的整个过程中，只要任何一个环节出了问题，最后都会影响系统的稳定性。所以，我们需要一个重试的机制。但是，我们需要明白的是，“重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试。

### 重试的场景
1. 服务timeout超时异常
2. 服务不存在，配置问题，服务流控
3. 对error错误不重试，如无权限、参数错误

### 重试策略

1. 设置重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。
2. 每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。

### 重试需要注意的地方
1. 服务幂等性，在重试时需证调用服务的幂等性
2. 重试数据的监控，邮件，短信及时通知
3. 重试数据的结转，防止表数据量过大

## 2020-01-04

### 熔断设计

> 分布式系统设计中，应该有类似保险丝，跳闸等方式。重试机制中，如果错误太多，或是在短时间内得不到修复，那么重试也没有意义，此时应该开启熔断，尤其是后端太忙的时候，使用熔断设计可以保护后端不会过载。

熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正。如果已经修正，应用程序会再次尝试调用操作。

### 熔断状态

1. 闭合（Closed）状态：我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。
2. 断开 (Open) 状态：在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。
3. 半开（Half-Open）状态：允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。

## 2020-01-06

### 限流设计

保护系统不会在过载的情况下出现问题，需要限流。

数据库访问的连接池，线程池，还有 Nginx 下的用于限制瞬时并发连接数的 limit_conn 模块，限制每秒平均速率的 limit_req 模块，还有限制 MQ 的生产速，等等。

### 限流的策略

限流的目的是通过对并发访问进行限速，相关的策略一般是，一旦达到限制的速率，那么就会触发相应的限流行为。一般来说，触发的限流行为如下。

1. 拒绝服务。把多出来的请求拒绝掉。一般来说，统计当前客户端来的请求，直接拒掉不正常客户端，这种行为可以把一些不正常的或者是带有恶意的高并发访问挡在门外。
2. 服务降级。降级有很多方式，一种是把一些不重要的服务给停掉，把 CPU、内存或是数据的资源让给更重要的功能；一种是不再返回全量数据，只返回部分数据。还有最快的一种是直接返回预设的缓存，以牺牲一致性的方式来获得更大的性能吞吐。
3. 特权请求。所谓特权请求，就是资源不够了，把有限的资源分给重要的用户，比如：分给权利更高的 VIP 用户。
4. 延时处理。在这种情况下，一般会有一个队列来缓冲大量的请求，这个队列如果满了，那么就只能拒绝用户了，如果这个队列中的任务超时了，也要返回系统繁忙的错误了。使用缓冲队列只是为了减缓压力，一般用于应对短暂的峰刺请求。
5. 弹性伸缩。动用自动化运维的方式对相应的服务做自动化的伸缩。这个需要一个应用性能的监控系统，能够感知到目前最繁忙的 TOP 5 的服务是哪几个。然后去伸缩它们，还需要一个自动化的发布、部署和服务注册的运维系统，而且还要快，越快越好。否则，系统会被压死掉了。当然，如果是数据库的压力过大，弹性伸缩应用是没什么用的，这个时候还是应该限流。

### 限流的实现方式

计数器方式
队列算法
漏斗算法 Leaky Bucket
令牌桶算法 Token Bucket

## 2020-01-07

### 降级设计

降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。

### 降级需要牺牲掉的东西有：
1. 降低一致性。从强一致性变成最终一致性。
1. 停止次要功能。停止访问不重要的功能，从而释放出更多的资源。
1. 简化功能。把一些功能简化掉，比如，简化业务流程，或是不再返回全量数据，只返回部分数据。
