## 数组(Array)

> 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

* 优点：支持随机访问，在知道下标的情况下时间复杂度为O(1), 不知道下标时，用二分法查找，时间复杂度为O(logn)

* 缺点:低效的插入与删除

        假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。时间复杂度为(1+2+...n)/n = O(n)
        如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。此时时间复杂度为O(1)

![无序数组插入操作](./resource/无序数组插入操作.jpg)

        和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)

        实际上，在某些特殊场景下，不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率将会有很大提升

        数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。

![多个删除操作](./resource/多个删除操作.jpg)

        为了避免 d，e，f，g，h 这几个数据会被搬移三次，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。(标记清除垃圾回收算法核心思想)

> 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

    从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”.如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：

<b>a[k]_address = base_address + k × type_size</b>

    但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：

<b>a[k]_address = base_address + (k-1) × type_size</b>

    对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。
